import { writeFileSync } from "fs";
import { toSafeString } from "json-schema-to-typescript/dist/src/utils";

/** Stages of a k8s version */
enum Stage {
  Alpha = 0,
  Beta = 1,
  Stable = 2,
}

/** Get the parsed version components from a k8s apiVersion string (e.g. "v1", "v1beta1", "v2alpha3"). */
const parseVersion = (v: string) => {
  const match = v.match(/^v(\d+)(?:(alpha|beta)(\d+))?$/);
  if (!match) return null;
  const major = parseInt(match[1], 10);
  const stage = match[2] === "alpha" ? 0 : match[2] === "beta" ? 1 : 2;
  const minor = parseInt(match[3] || "0", 10);
  return { major, stage, minor } satisfies {
    major: number;
    stage: Stage;
    minor: number;
  };
};

/** Compare two k8s apiVersions (e.g. "v1", "v1beta1", "v2alpha3") */
const compareApiVersions = (a: string, b: string): number => {
  const verA = parseVersion(a);
  const verB = parseVersion(b);
  if (!verA || !verB) {
    // If either version is unparsable, consider them equal
    return 0;
  }
  if (verA.major !== verB.major) {
    return verA.major - verB.major;
  }
  if (verA.stage !== verB.stage) {
    return verA.stage - verB.stage;
  }
  return verA.minor - verB.minor;
};

/** Get the newest k8s apiVersion from a list of versions */
const getNewestVersion = (versions: string[]): string => {
  return versions.reduce((newest, current) => {
    return compareApiVersions(newest, current) >= 0 ? newest : current;
  }, versions[0]);
};

export interface CompilePromiseMetadata {
  kind: string;
  version: string;
}

export class IndexFileWriter {
  private promises: Promise<CompilePromiseMetadata>[] = [];

  addPromise(promise: Promise<CompilePromiseMetadata>) {
    this.promises.push(promise);
  }

  writeIndexFile(
    outputPath: string,
    header: string = `// This file is autogenerated from the corresponding resources.
// Do not edit this file directly.
`,
  ) {
    Promise.all(this.promises).then((results) => {
      const versions: Record<string, string[]> = {};

      results.filter(Boolean).map((i) => {
        if (!versions[i.kind]) versions[i.kind] = [];
        versions[i.kind].push(i.version);
      });

      const acc: string[] = [];

      // the newest version of each baseName also get reexported without the version prefix
      for (const [kind, vers] of Object.entries(versions)) {
        const newest = getNewestVersion(vers);

        acc.push(
          `export type { ${toSafeString(newest)}${kind}Kind as ${kind}Kind } from './${newest}${kind}';`,
        );

        for (const ver of vers) {
          acc.push(
            `export type { ${toSafeString(ver)}${kind}Kind } from './${ver}${kind}';`,
          );
        }
      }

      // create index file
      writeFileSync(
        outputPath,
        `${header}
${acc.join("\n")}
`,
      );
    });
  }
}
