import { writeFileSync } from "fs";
import { toSafeString } from "json-schema-to-typescript/dist/src/utils";
import { resolve } from "path";

/** Stages of a k8s version */
enum Stage {
  Alpha = 0,
  Beta = 1,
  Stable = 2,
}

/** Get the parsed version components from a k8s apiVersion string (e.g. "v1", "v1beta1", "v2alpha3"). */
const parseVersion = (v: string) => {
  const match = v.match(/^v(\d+)(?:(alpha|beta)(\d+))?$/);
  if (!match) return null;
  const major = parseInt(match[1], 10);
  const stage = match[2] === "alpha" ? 0 : match[2] === "beta" ? 1 : 2;
  const minor = parseInt(match[3] || "0", 10);
  return { major, stage, minor } satisfies {
    major: number;
    stage: Stage;
    minor: number;
  };
};

/** Compare two k8s apiVersions (e.g. "v1", "v1beta1", "v2alpha3") */
const compareApiVersions = (a: string, b: string): number => {
  const verA = parseVersion(a);
  const verB = parseVersion(b);
  if (!verA || !verB) {
    // If either version is unparsable, consider them equal
    return 0;
  }
  if (verA.major !== verB.major) {
    return verA.major - verB.major;
  }
  if (verA.stage !== verB.stage) {
    return verA.stage - verB.stage;
  }
  return verA.minor - verB.minor;
};

export interface CompilePromiseMetadata {
  kind: string;
  version: string;
  interfaceName: string;
  fileName: string;
}

/** Get the newest k8s apiVersion from a list of versions */
const getNewestVersion = (versions: CompilePromiseMetadata[]): CompilePromiseMetadata => {
  return versions.reduce((newest, current) => {
    return compareApiVersions(current.version, newest.version) > 0 ? current
      : newest;
  }, versions[0]);
};

export class IndexFileWriter {
  private promises: Promise<CompilePromiseMetadata>[] = [];

  addPromise(promise: Promise<CompilePromiseMetadata>) {
    this.promises.push(promise);
  }

  writeIndexFile(
    outputPath: string,
    header: string = `// This file is autogenerated from the corresponding resources.
// Do not edit this file directly.
`,
  ) {
    Promise.all(this.promises).then((results) => {
      const versions: Record<string, CompilePromiseMetadata[]> = {};

      results.filter(Boolean).map((i) => {
        if (!versions[i.kind]) versions[i.kind] = [];
        versions[i.kind].push(i);
      });

      const accLatest: string[] = [];
      const accComprehensive: string[] = [];

      // the newest version of each baseName also get reexported without the version prefix
      for (const [kind, vers] of Object.entries(versions)) {
        const newest = getNewestVersion(vers);

        accLatest.push(
          `export type { ${toSafeString(newest.interfaceName)} as ${kind}Kind } from './${newest.fileName}';`,
        );

        for (const ver of vers) {
          accComprehensive.push(
            `export type { ${toSafeString(ver.interfaceName)} } from './${ver.fileName}';`,
          );
        }
      }

      // create index files
      writeFileSync(
        resolve(outputPath, "index.d.ts"),
        `${header}
${accLatest.join("\n")}
`,
      );

      writeFileSync(
        resolve(outputPath, "all.d.ts"),
        `${header}
${accComprehensive.join("\n")}
`,
      );
    });
  }
}
