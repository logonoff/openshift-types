import { readdirSync, writeFile, writeFileSync } from "fs";
import { compile } from "json-schema-to-typescript";
import { extname, resolve } from "path";
import type { CustomResourceDefinitionKind } from "./types";
import { bannerComment, dedupe, extendInterface, loadYAML } from "./utils";
import { JSONSchema4 } from "json-schema";

/**
 * Generate TypeScript types from OpenShift CustomResourceDefinitions (CRDs).
 *
 * Limitations:
 * - Only the first (newest) version in the versions list is used.
 */
export const generateOpenShiftTypesFromAPI = () => {
  // parse all CRDs from generated/openshift-crds
  const files = readdirSync(resolve(__dirname, "../generated/openshift-crds"));

  const CRDs: Record<string, CustomResourceDefinitionKind> = {};

  for (const file of files) {
    if (extname(file) !== ".yaml") continue;

    const doc = loadYAML<CustomResourceDefinitionKind>(
      `../generated/openshift-crds/${file}`,
    );

    if (doc.kind !== "CustomResourceDefinition") {
      console.warn(`Skipping non-CRD file: ${file}`);
      continue;
    }

    const name = doc.metadata.name;
    CRDs[name] = doc;
  }

  // generate types for each CRD
  const compilePromises: Promise<string>[] = [];

  for (const [name, crd] of Object.entries(CRDs)) {
    const usedVersion = crd.spec.versions?.[0];
    const schema = usedVersion.schema.openAPIV3Schema;

    const group = crd.spec.group;
    const kind = crd.spec.names.kind;

    // delete common properties that are always present (we will use our own)
    if (schema.properties) {
      delete schema.properties.apiVersion;
      delete schema.properties.kind;
      delete schema.properties.metadata;
    }

    // append group~version~kind to banner comment
    schema.description += `\n\n@version \`${group}~${usedVersion.name}~${kind}\``;

    // append @alpha or @beta to description if applicable
    if (usedVersion.name.includes("alpha")) schema.description += `\n@alpha`;
    else if (usedVersion.name.includes("beta")) schema.description += `\n@beta`;

    const typeName = `${kind}Kind`;

    const promise = compile(schema as JSONSchema4, typeName, {
      additionalProperties: false,
      bannerComment,
      ignoreMinAndMaxItems: true,
      format: false,
    })
      .then((ts) => {
        // write type to src/generated/[baseName].d.ts
        const baseName =
          kind.match(/^v\d+(alpha\d+|beta\d+)?(.*)$/)?.[2] ?? kind;
        const filePath = resolve(
          __dirname,
          `../generated/types/openshift/${baseName}.d.ts`,
        );
        writeFile(
          filePath,
          extendInterface(ts, typeName, "K8sResourceCommon"),
          (err) => {
            if (err) {
              console.error(`Error writing type file for CRD: ${name}`, err);
            }
          },
        );
        return filePath;
      })
      .catch((err) => {
        console.error(`Error generating types for CRD: ${name}`, err);
        return "";
      });

    compilePromises.push(promise);
  }

  Promise.all(compilePromises).then((results) => {
    const acc = results.filter(Boolean).map((filePath) => {
      const typeName = filePath.match(/\/([^\/]+)\.d\.ts$/)?.[1];
      return `export type { ${typeName}Kind } from './${typeName}';`;
    });
    // create src/generated/openshift-crds.d.ts
    writeFileSync(
      resolve(__dirname, "../generated/types/openshift/index.d.ts"),
      `
// This file is autogenerated from the corresponding OpenShift CustomResourceDefinitions.
// Do not edit this file directly.

// Types generated from ${process.env.OPENSHIFT_API_COMMIT ?? "unknown commit"}

${dedupe<string>(acc).sort().join("\n")}

`,
    );
  });
};
