import { readdirSync, writeFile } from "fs";
import { JSONSchema4 } from "json-schema";
import { compile } from "json-schema-to-typescript";
import { extname, resolve } from "path";
import type { V1CustomResourceDefinitionKind } from "./k8s/CustomResourceDefinition";
import { customizeK8sSchema } from "./utils/customizeK8sSchema";
import { extendK8sInterface } from "./utils/extendK8sInterface";
import { IndexFileWriter } from "./utils/IndexFileWriter";
import { loadYAML } from "./utils/loadYAML";
import { schemaToTsConfig } from "./utils/schemaToTsConfig";
import { toSafeString } from "./utils/toSafeString";

const fetchCRDs = (): Record<string, V1CustomResourceDefinitionKind> => {
  // parse all CRDs from generated/openshift-crds
  const files = readdirSync(resolve(__dirname, "../generated/openshift-crds"));

  const CRDs: Record<string, V1CustomResourceDefinitionKind> = {};

  for (const file of files) {
    if (extname(file) !== ".yaml") continue;

    const doc = loadYAML<V1CustomResourceDefinitionKind>(
      `../../generated/openshift-crds/${file}`,
    );

    if (doc.kind !== "CustomResourceDefinition" || !doc?.metadata?.name) {
      console.warn(`Skipping non-CRD file: ${file}`);
      continue;
    }

    const name = doc.metadata.name;
    CRDs[name] = doc;
  }

  return CRDs;
};

/**
 * Generate TypeScript types from OpenShift CustomResourceDefinitions (CRDs).
 *
 * Limitations:
 * - Only the first (newest) version in the versions list is used.
 */
export const generateOpenShiftTypesFromAPI = () => {
  const CRDs = fetchCRDs();

  const compilePromises = new IndexFileWriter();

  const interfaces: Set<string> = new Set();

  for (const [name, crd] of Object.entries(CRDs)) {
    const group = crd.spec.group;
    const kind = crd.spec.names.kind;

    for (const usedVersion of crd.spec.versions ?? []) {
      if (!usedVersion || !usedVersion.schema?.openAPIV3Schema) {
        console.warn(`Skipping ${name}: no schema defined.`);
        continue;
      }

      const schema = usedVersion.schema.openAPIV3Schema as JSONSchema4;

      customizeK8sSchema(schema, group, usedVersion.name, kind);

      const baseName = `${usedVersion.name}${kind}`;
      const fileName = `${baseName}.d.ts`;
      const interfaceName = `${toSafeString(baseName)}Kind`;

      // the parser may go through multiple versions of the same kind, but we only want one
      // this prevents multiple file writers from writing to the same file
      if (interfaces.has(interfaceName)) {
        console.warn(
          `Skipping ${name}: interface ${interfaceName} already exists.`,
        );
        continue;
      }
      interfaces.add(interfaceName);

      const promise = compile(schema, interfaceName, schemaToTsConfig)
        .then((ts) => {
          writeFile(
            resolve(__dirname, `../generated/types/openshift/${fileName}`),
            extendK8sInterface(ts, schema, interfaceName),
            (err) => {
              if (err) {
                console.error(`Error writing type file for CRD: ${name}`, err);
              }
            },
          );
          return {
            kind,
            version: usedVersion.name,
          };
        })
        .catch((err) => {
          console.error(`Error generating types for CRD: ${name}`, err);
          throw err;
        });

      compilePromises.addPromise(promise);
    }
  }

  compilePromises.writeIndexFile(
    resolve(__dirname, "../generated/types/openshift/index.d.ts"),
    `// This file is autogenerated from the corresponding OpenShift CustomResourceDefinitions.
// Do not edit this file directly.
`,
  );
};
