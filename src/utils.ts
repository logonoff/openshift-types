import { readFileSync } from "fs";
import { load as parseYAML } from "js-yaml";
import { JSONSchema4, JSONSchema7 } from "json-schema";
import { Options } from "json-schema-to-typescript";
import { resolve } from "path";

/** Parse a YAML file and return the parsed object */
export const loadYAML = <T>(filePath: string): T => {
  const fullPath = resolve(__dirname, filePath);
  const fileContents = readFileSync(fullPath, "utf8");
  return parseYAML(fileContents) as T;
};

/**
 * Takes a TypeScript interface as a string and adds an "extends ..." clause to it
 *
 * Assumes this has not already been done.
 */
export const extendInterface = (
  ts: string,
  interfaceName: string,
  extension: string,
): string => {
  const interfaceRegex = new RegExp(`(export interface ${interfaceName} )({)`);
  return ts.replace(interfaceRegex, `$1extends ${extension} $2`);
};

/** Fetch but the response is stored in disk */
export const cachedFetch: typeof fetch = async (url, options) => {
  const cachePath = resolve(
    __dirname,
    "../cached",
    encodeURIComponent(url.toString()) + ".json",
  );
  try {
    const data = readFileSync(cachePath, "utf8");
    return new Response(data, { status: 200 });
  } catch (err) {
    const res = await fetch(url, options);
    const data = await res.text();
    if (res.ok) {
      import("fs").then((fs) => {
        fs.writeFileSync(cachePath, data, "utf8");
      });
    }
    // Return a new Response so the body can be read again
    return new Response(data, { ...res });
  }
};

/**
 * Provides a reference string that uniquely identifies the group, version, and kind of a k8s resource.
 *
 * @param group Pass group of k8s resource or model.
 * @param version Pass version of k8s resource or model.
 * @param kind Pass kind of k8s resource or model.
 * @returns The reference for any k8s resource i.e `group~version~kind`.
 *
 * If the group will not be present then "core" will be returned as part of the group in reference.
 */
export const getReference = (
  group: string,
  version: string,
  kind: string,
): string => [group || "core", version, kind].join("~");

/** Removes common properties addressed by `K8sResourceCommon` and add some TSDoc tags */
export const customizeK8sSchema = (
  schema: JSONSchema7 | JSONSchema4,
  group: string,
  version: string,
  kind: string,
) => {
  // delete common properties that are always present (we will use our own)
  if (schema.properties) {
    delete schema.properties.apiVersion;
    delete schema.properties.kind;
    delete schema.properties.metadata;
  }

  // append group~version~kind to banner comment
  schema.description += `\n\n@version \`${getReference(group, version, kind)}\``;

  // append @alpha or @beta to description if applicable
  if (version.includes("alpha")) schema.description += `\n@alpha`;
  else if (version.includes("beta")) schema.description += `\n@beta`;
};

/** Preferred config options for `json-schema-to-typescript`. */
export const schemaToTsConfig: Partial<Options> = {
  // prevent `[k: string]: unknown` from being added everywhere
  additionalProperties: false,
  bannerComment: [
    "/**",
    " * This file is autogenerated from the corresponding API definitions.",
    " * Do not edit this file directly.",
    " */",
    "",
    "import type { K8sResourceCommon } from '../K8sResourceCommon';",
  ].join("\n"),
  ignoreMinAndMaxItems: true,
  // prettier is done last in generate script
  format: false,
};
