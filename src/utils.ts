import { readFileSync, writeFileSync } from "fs";
import { load as parseYAML } from "js-yaml";
import { JSONSchema4, JSONSchema7 } from "json-schema";
import { Options } from "json-schema-to-typescript";
import { toSafeString } from "json-schema-to-typescript/dist/src/utils";
import { resolve } from "path";

/** Parse a YAML file and return the parsed object */
export const loadYAML = <T>(filePath: string): T => {
  const fullPath = resolve(__dirname, filePath);
  const fileContents = readFileSync(fullPath, "utf8");
  return parseYAML(fileContents) as T;
};

/**
 * Takes a TypeScript interface as a string and adds an "extends ..." clause to it
 *
 * Assumes this has not already been done.
 */
const extendInterface = (
  ts: string,
  interfaceName: string,
  extension: string,
): string => {
  const interfaceRegex = new RegExp(`(export interface ${interfaceName} )({)`);
  return ts.replace(interfaceRegex, `$1extends ${extension} $2`);
};

/** Check if one field is required in a JSON schema */
const isFieldRequired = (schema: JSONSchema4, fieldName: string): boolean => {
  return Array.isArray(schema.required) && schema.required.includes(fieldName);
};

/** Check if multiple fields are required in a JSON schema and return the required ones */
const areFieldsRequired = (
  schema: JSONSchema4,
  fieldNames: string[],
): string[] => {
  return fieldNames.filter((name) => isFieldRequired(schema, name));
};

/** Determine the appropriate common interface to extend based on required fields */
const getCommonInterface = (schema: JSONSchema4) => {
  const requiredFields = areFieldsRequired(schema, [
    "apiVersion",
    "kind",
    "metadata",
  ]);
  if (requiredFields.length === 0) return "K8sResourceCommon";
  return `RequiredK8sResourceCommon<"${requiredFields.join('" | "')}">`;
};

/** Extend a TypeScript interface string with the appropriate K8sResourceCommon variant */
export const extendK8sInterface = (
  ts: string,
  schema: JSONSchema4,
  interfaceName: string,
) => {
  const commonInterface = getCommonInterface(schema);
  return extendInterface(ts, interfaceName, commonInterface);
};

/** Fetch but the response is stored in disk */
export const cachedFetch: typeof fetch = async (url, options) => {
  const cachePath = resolve(
    __dirname,
    "../cached",
    encodeURIComponent(url.toString()) + ".json",
  );
  try {
    const data = readFileSync(cachePath, "utf8");
    return new Response(data, { status: 200 });
  } catch (err) {
    const res = await fetch(url, options);
    const data = await res.text();
    if (res.ok) {
      import("fs").then((fs) => {
        fs.writeFileSync(cachePath, data, "utf8");
      });
    }
    // Return a new Response so the body can be read again
    return new Response(data, { ...res });
  }
};

/**
 * Provides a reference string that uniquely identifies the group, version, and kind of a k8s resource.
 *
 * @param group Pass group of k8s resource or model.
 * @param version Pass version of k8s resource or model.
 * @param kind Pass kind of k8s resource or model.
 * @returns The reference for any k8s resource i.e `group~version~kind`.
 *
 * If the group will not be present then "core" will be returned as part of the group in reference.
 */
export const getReference = (
  group: string,
  version: string,
  kind: string,
): string => [group || "core", version, kind].join("~");

/** Removes common properties addressed by `K8sResourceCommon` and add some TSDoc tags */
export const customizeK8sSchema = (
  schema: JSONSchema7 | JSONSchema4,
  group: string,
  version: string,
  kind: string,
) => {
  // delete common properties that are always present (we will use our own)
  if (schema.properties) {
    delete schema.properties.apiVersion;
    delete schema.properties.kind;
    delete schema.properties.metadata;
  }

  // append group~version~kind to banner comment
  schema.description += `\n\n@version \`${getReference(group, version, kind)}\``;

  // append @alpha or @beta to description if applicable
  if (version.includes("alpha")) schema.description += `\n@alpha`;
  else if (version.includes("beta")) schema.description += `\n@beta`;
};

/** Preferred config options for `json-schema-to-typescript`. */
export const schemaToTsConfig: Partial<Options> = {
  // prevent `[k: string]: unknown` from being added everywhere
  additionalProperties: false,
  bannerComment: [
    "/**",
    " * This file is autogenerated from the corresponding API definitions.",
    " * Do not edit this file directly.",
    " */",
    "",
    "import type { K8sResourceCommon, RequiredK8sResourceCommon } from '../K8sResourceCommon';",
  ].join("\n"),
  ignoreMinAndMaxItems: true,
  // prettier is done last in generate script
  format: false,
};

/** Stages of a k8s version */
enum Stage {
  Alpha = 0,
  Beta = 1,
  Stable = 2,
}

/** Get the parsed version components from a k8s apiVersion string (e.g. "v1", "v1beta1", "v2alpha3"). */
const parseVersion = (v: string) => {
  const match = v.match(/^v(\d+)(?:(alpha|beta)(\d+))?$/);
  if (!match) return null;
  const major = parseInt(match[1], 10);
  const stage = match[2] === "alpha" ? 0 : match[2] === "beta" ? 1 : 2;
  const minor = parseInt(match[3] || "0", 10);
  return { major, stage, minor } satisfies {
    major: number;
    stage: Stage;
    minor: number;
  };
};

/** Compare two k8s apiVersions (e.g. "v1", "v1beta1", "v2alpha3") */
const compareApiVersions = (a: string, b: string): number => {
  const verA = parseVersion(a);
  const verB = parseVersion(b);
  if (!verA || !verB) {
    // If either version is unparsable, consider them equal
    return 0;
  }
  if (verA.major !== verB.major) {
    return verA.major - verB.major;
  }
  if (verA.stage !== verB.stage) {
    return verA.stage - verB.stage;
  }
  return verA.minor - verB.minor;
};

/** Get the newest k8s apiVersion from a list of versions */
const getNewestVersion = (versions: string[]): string => {
  return versions.reduce((newest, current) => {
    return compareApiVersions(newest, current) >= 0 ? newest : current;
  }, versions[0]);
};

export { toSafeString } from "json-schema-to-typescript/dist/src/utils";

export interface CompilePromiseMetadata {
  kind: string;
  version: string;
}

export class IndexFileWriter {
  private promises: Promise<CompilePromiseMetadata>[] = [];

  addPromise(promise: Promise<CompilePromiseMetadata>) {
    this.promises.push(promise);
  }

  writeIndexFile(
    outputPath: string,
    header: string = `// This file is autogenerated from the corresponding resources.
// Do not edit this file directly.
`,
  ) {
    Promise.all(this.promises).then((results) => {
      const versions: Record<string, string[]> = {};

      results.filter(Boolean).map((i) => {
        if (!versions[i.kind]) versions[i.kind] = [];
        versions[i.kind].push(i.version);
      });

      const acc: string[] = [];

      // the newest version of each baseName also get reexported without the version prefix
      for (const [kind, vers] of Object.entries(versions)) {
        const newest = getNewestVersion(vers);

        acc.push(
          `export type { ${toSafeString(newest)}${kind}Kind as ${kind}Kind } from './${newest}${kind}';`,
        );

        for (const ver of vers) {
          acc.push(
            `export type { ${toSafeString(ver)}${kind}Kind } from './${ver}${kind}';`,
          );
        }
      }

      // create index file
      writeFileSync(
        outputPath,
        `${header}
${acc.join("\n")}
`,
      );
    });
  }
}
