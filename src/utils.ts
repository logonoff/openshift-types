import { readFileSync } from "fs";
import { load as parseYAML } from "js-yaml";
import { resolve } from "path";

/** Parse a YAML file and return the parsed object */
export const loadYAML = <T>(filePath: string): T => {
  const fullPath = resolve(__dirname, filePath);
  const fileContents = readFileSync(fullPath, "utf8");
  return parseYAML(fileContents) as T;
};

/**
 * Takes a TypeScript interface as a string and adds an "extends ..." clause to it
 *
 * Assumes this has not already been done.
 */
export const extendInterface = (
  ts: string,
  interfaceName: string,
  extension: string,
): string => {
  const interfaceRegex = new RegExp(`(export interface ${interfaceName} )({)`);
  return ts.replace(interfaceRegex, `$1extends ${extension} $2`);
};

/** A standard banner comment to put at the top of generated files */
export const bannerComment = [
  "/**",
  " * This file is autogenerated from the corresponding CustomResourceDefinition.",
  " * Do not edit this file directly.",
  " */",
  "",
  "import type { K8sResourceCommon } from '../K8sResourceCommon';",
].join("\n");

/** Remove duplicate entries from an array */
export const dedupe = <T>(arr: T[]): T[] => {
  return Array.from(new Set(arr));
};

/** Fetch but the response is stored in disk */
export const cachedFetch: typeof fetch = async (url, options) => {
  const cachePath = resolve(
    __dirname,
    "../cached",
    encodeURIComponent(url.toString()) + ".json",
  );
  try {
    const data = readFileSync(cachePath, "utf8");
    return new Response(data, { status: 200 });
  } catch (err) {
    const res = await fetch(url, options);
    const data = await res.text();
    if (res.ok) {
      import("fs").then((fs) => {
        fs.writeFileSync(cachePath, data, "utf8");
      });
    }
    // Return a new Response so the body can be read again
    return new Response(data, { ...res });
  }
};
