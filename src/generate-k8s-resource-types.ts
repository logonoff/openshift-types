import { writeFile, writeFileSync } from "fs";
import { compile } from "json-schema-to-typescript";
import { resolve } from "path";
import { cachedFetch, dedupe, extendInterface, bannerComment } from "./utils";
import { JSONSchema4 } from "json-schema";

const OPENSHIFT_K8S_SWAGGER =
  "https://raw.githubusercontent.com/openshift/kubernetes/refs/heads/master/api/openapi-spec/swagger.json";

interface K8sGVK {
  group: string;
  version: string;
  kind: string;
}

interface K8sDefinition extends JSONSchema4 {
  "x-kubernetes-group-version-kind": K8sGVK[];
}

export const generateKubernetesTypesFromSwagger = () => {
  // fetch swagger.json from OPENSHIFT_K8S_SWAGGER
  cachedFetch(OPENSHIFT_K8S_SWAGGER)
    .then((res) => res.json())
    .then((swagger) => {
      // find all definitions that are CustomResourceDefinitions
      const definitions = swagger.definitions as JSONSchema4;

      // filter definitions that have 'x-kubernetes-group-version-kind' property
      // these are the resources we want to generate types for
      const crdDefinitions: Record<string, K8sDefinition> = {};

      for (const [name, def] of Object.entries(definitions)) {
        if (def["x-kubernetes-group-version-kind"]) {
          crdDefinitions[name] = def;
        }
      }

      // generate types for each CRD definition
      const compilePromises: Promise<string>[] = [];

      for (const [name, def] of Object.entries(crdDefinitions)) {
        // Only generate types if there are properties defined
        if (!def.properties || Object.keys(def.properties).length === 0) {
          console.warn(`Skipping ${name}: no properties defined in schema.`);
          continue;
        }

        const { group, version, kind } =
          def["x-kubernetes-group-version-kind"][0];
        const interfaceName = `${kind}Kind`;
        const fileName = `${kind}.d.ts`;
        const filePath = resolve(
          __dirname,
          `../generated/types/kubernetes/${fileName}`,
        );

        // Clone the definition to avoid modifying the original
        const modifiedDef = JSON.parse(JSON.stringify(def));

        // delete common properties that are always present (we will use our own)
        delete modifiedDef.properties.apiVersion;
        delete modifiedDef.properties.kind;
        delete modifiedDef.properties.metadata;

        // append group~version~kind to banner comment
        modifiedDef.description =
          (modifiedDef.description || "") +
          `\n\n@version \`${group}~${version}~${kind}\``;

        // append @alpha or @beta to description if applicable
        if (version.includes("alpha")) modifiedDef.description += `\n@alpha`;
        else if (version.includes("beta")) modifiedDef.description += `\n@beta`;

        // Create a schema with the modified definition and all the referenced definitions
        const schema = {
          definitions: swagger.definitions,
          ...modifiedDef,
        };

        const compilePromise = compile(schema, interfaceName, {
          additionalProperties: false,
          bannerComment,
          ignoreMinAndMaxItems: true,
          format: false,
        })
          .then((ts) => {
            return new Promise<string>((resolve, reject) => {
              writeFile(
                filePath,
                extendInterface(ts, interfaceName, "K8sResourceCommon"),
                (err) => {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(filePath);
                  }
                },
              );
            });
          })
          .catch((err) => {
            console.error(`Error compiling schema for ${name}`, err);
            return "";
          });

        compilePromises.push(compilePromise);
      }

      // wait for all compile promises to finish
      // then create an index file exporting all types
      Promise.all(compilePromises).then((results) => {
        const acc = results.filter(Boolean).map((filePath) => {
          const typeName = filePath.match(/\/([^\/]+)\.d\.ts$/)?.[1];
          return `export type { ${typeName}Kind } from './${typeName}';`;
        });
        // create src/generated/kubernetes-crds.d.ts
        writeFileSync(
          resolve(__dirname, "../generated/types/kubernetes/index.d.ts"),
          `// This file is autogenerated from the corresponding Kubernetes resources.
// Do not edit this file directly.

${dedupe<string>(acc).sort().join("\n")}

`,
        );
      });
    })
    .catch((err) => {
      console.error(
        "Error fetching or processing Kubernetes swagger.json",
        err,
      );
    });
};
