import { mkdirSync, writeFile } from "fs";
import { JSONSchema4 } from "json-schema";
import { compile } from "json-schema-to-typescript";
import { dirname, resolve } from "path";
import { cachedFetch } from "./utils/cachedFetch";
import { customizeK8sSchema } from "./utils/customizeK8sSchema";
import { extendK8sInterface } from "./utils/extendK8sInterface";
import {
  CompilePromiseMetadata,
  IndexFileWriter,
} from "./utils/IndexFileWriter";
import { schemaToTsConfig } from "./utils/schemaToTsConfig";
import { toSafeString } from "./utils/toSafeString";

const OPENSHIFT_K8S_SWAGGER =
  "https://raw.githubusercontent.com/openshift/kubernetes/refs/heads/master/api/openapi-spec/swagger.json";

interface K8sDefinition extends JSONSchema4 {
  "x-kubernetes-group-version-kind": {
    group: string;
    version: string;
    kind: string;
  }[];
}

export const generateKubernetesTypesFromSwagger = async () => {
  // fetch swagger.json from OPENSHIFT_K8S_SWAGGER
  await cachedFetch(OPENSHIFT_K8S_SWAGGER)
    .then((res) => res.json())
    .then(async (swagger) => {
      // find all definitions that are CustomResourceDefinitions
      const definitions = swagger.definitions as JSONSchema4;

      // filter definitions that have 'x-kubernetes-group-version-kind' property
      // these are the resources we want to generate types for
      const crdDefinitions: Record<string, K8sDefinition> = {};

      for (const [name, def] of Object.entries(definitions)) {
        if (def["x-kubernetes-group-version-kind"]) {
          crdDefinitions[name] = def;
        }
      }

      const compilePromises = new IndexFileWriter();

      for (const [name, def] of Object.entries(crdDefinitions)) {
        // Only generate types if there are properties defined
        if (!def.properties || Object.keys(def.properties).length === 0) {
          console.warn(`Skipping ${name}: no properties defined in schema.`);
          continue;
        }

        const { group, version, kind } =
          def["x-kubernetes-group-version-kind"][0];

        // Create a clone of the definition to avoid mutating the original
        const schema: JSONSchema4 = {
          definitions: swagger.definitions,
          ...JSON.parse(JSON.stringify(def)),
        };

        customizeK8sSchema(schema, group, version, kind);

        const fileName = `${group || "core"}/${version}/${kind}.d.ts`;
        const interfaceName = toSafeString(`${kind}Kind`);

        const path = resolve(
          __dirname,
          `../generated/types/kubernetes/${fileName}`,
        );

        const promise = compile(schema, interfaceName, schemaToTsConfig(path))
          .then((ts) => {
            mkdirSync(dirname(path), { recursive: true });
            writeFile(
              path,
              extendK8sInterface(ts, schema, interfaceName),
              (err) => {
                if (err) {
                  console.error(
                    `Error writing type file for CRD: ${name}`,
                    err,
                  );
                }
              },
            );
            return {
              group,
              kind,
              version,
              interfaceName,
              fileName,
            } satisfies CompilePromiseMetadata;
          })
          .catch((err) => {
            console.error(`Error compiling schema for ${name}`, err);
            throw err;
          });

        compilePromises.addPromise(promise);
      }

      await compilePromises.writeIndexFile(
        resolve(__dirname, "../generated/types/kubernetes"),
        `// This file is autogenerated from the corresponding Kubernetes resources.
 // Do not edit this file directly.
 `,
      );
    })
    .catch((err) => {
      console.error(
        "Error fetching or processing Kubernetes swagger.json",
        err,
      );
    });
};
