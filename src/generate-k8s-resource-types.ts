import { writeFile } from "fs";
import { JSONSchema4 } from "json-schema";
import { compile } from "json-schema-to-typescript";
import { resolve } from "path";
import { cachedFetch } from "./utils/cachedFetch";
import { customizeK8sSchema } from "./utils/customizeK8sSchema";
import { extendK8sInterface } from "./utils/extendK8sInterface";
import { IndexFileWriter } from "./utils/IndexFileWriter";
import { schemaToTsConfig } from "./utils/schemaToTsConfig";
import { toSafeString } from "./utils/toSafeString";

const OPENSHIFT_K8S_SWAGGER =
  "https://raw.githubusercontent.com/openshift/kubernetes/refs/heads/master/api/openapi-spec/swagger.json";

interface K8sDefinition extends JSONSchema4 {
  "x-kubernetes-group-version-kind": {
    group: string;
    version: string;
    kind: string;
  }[];
}

export const generateKubernetesTypesFromSwagger = () => {
  // fetch swagger.json from OPENSHIFT_K8S_SWAGGER
  cachedFetch(OPENSHIFT_K8S_SWAGGER)
    .then((res) => res.json())
    .then((swagger) => {
      // find all definitions that are CustomResourceDefinitions
      const definitions = swagger.definitions as JSONSchema4;

      // filter definitions that have 'x-kubernetes-group-version-kind' property
      // these are the resources we want to generate types for
      const crdDefinitions: Record<string, K8sDefinition> = {};

      for (const [name, def] of Object.entries(definitions)) {
        if (def["x-kubernetes-group-version-kind"]) {
          crdDefinitions[name] = def;
        }
      }

      const compilePromises = new IndexFileWriter();

      const interfaces: Set<string> = new Set();

      for (const [name, def] of Object.entries(crdDefinitions)) {
        // Only generate types if there are properties defined
        if (!def.properties || Object.keys(def.properties).length === 0) {
          console.warn(`Skipping ${name}: no properties defined in schema.`);
          continue;
        }

        const { group, version, kind } =
          def["x-kubernetes-group-version-kind"][0];

        // Create a clone of the definition to avoid mutating the original
        const schema: JSONSchema4 = {
          definitions: swagger.definitions,
          ...JSON.parse(JSON.stringify(def)),
        };

        customizeK8sSchema(schema, group, version, kind);

        const baseName = `${version}${kind}`;
        const fileName = `${baseName}.d.ts`;
        const interfaceName = toSafeString(`${version}${kind}Kind`);

        // the parser may go through multiple versions of the same kind, but we only want one
        // this prevents multiple file writers from writing to the same file
        if (interfaces.has(interfaceName)) {
          console.warn(
            `Skipping ${name}: interface ${interfaceName} already exists.`,
          );
          continue;
        }
        interfaces.add(interfaceName);

        const promise = compile(schema, interfaceName, schemaToTsConfig)
          .then((ts) => {
            writeFile(
              resolve(__dirname, `../generated/types/kubernetes/${fileName}`),
              extendK8sInterface(ts, schema, interfaceName),
              (err) => {
                if (err) {
                  console.error(
                    `Error writing type file for CRD: ${name}`,
                    err,
                  );
                }
              },
            );
            return {
              kind,
              version,
            };
          })
          .catch((err) => {
            console.error(`Error compiling schema for ${name}`, err);
            throw err;
          });

        compilePromises.addPromise(promise);
      }

      compilePromises.writeIndexFile(
        resolve(__dirname, "../generated/types/kubernetes/index.d.ts"),
        `// This file is autogenerated from the corresponding Kubernetes resources.
 // Do not edit this file directly.
 `,
      );
    })
    .catch((err) => {
      console.error(
        "Error fetching or processing Kubernetes swagger.json",
        err,
      );
    });
};
